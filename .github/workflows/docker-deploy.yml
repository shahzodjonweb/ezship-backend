name: Docker Deploy

on:
  push:
    branches: [ master, dev ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=raw,value=latest,enable={{is_default_branch}}
          type=sha

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
    - name: Set deployment variables
      id: vars
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
          echo "ENV_TYPE=prod" >> $GITHUB_OUTPUT
          echo "COMPOSE_FILE=docker-compose.prod.yml" >> $GITHUB_OUTPUT
          echo "ENV_FILE=.env.prod" >> $GITHUB_OUTPUT
          echo "CONTAINER_NAME=ezship-app-prod" >> $GITHUB_OUTPUT
          echo "API_URL=https://api.ezship.app" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/dev" || "${{ github.ref }}" == "refs/heads/develop" ]]; then
          echo "ENV_TYPE=dev" >> $GITHUB_OUTPUT
          echo "COMPOSE_FILE=docker-compose.dev.yml" >> $GITHUB_OUTPUT
          echo "ENV_FILE=.env.dev" >> $GITHUB_OUTPUT
          echo "CONTAINER_NAME=ezship-app-dev" >> $GITHUB_OUTPUT
          echo "API_URL=https://api-dev.ezship.app" >> $GITHUB_OUTPUT
        fi

    - name: Deploy via SSH
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SERVER_SSH_KEY }}
        port: ${{ secrets.SERVER_PORT || 22 }}
        script: |
          # Navigate to deployment directory
          cd /opt/ezship
          
          # Pull latest code
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            git checkout master && git pull origin master
          else
            git checkout develop && git pull origin develop || git pull origin dev
          fi
          
          # Create environment file from GitHub Secret
          if [[ "${{ steps.vars.outputs.ENV_TYPE }}" == "prod" ]]; then
            cat > ${{ steps.vars.outputs.ENV_FILE }} << 'EOF'
          ${{ secrets.PRODUCTION_ENV_FILE }}
          EOF
          else
            cat > ${{ steps.vars.outputs.ENV_FILE }} << 'EOF'
          ${{ secrets.DEVELOPMENT_ENV_FILE }}
          EOF
          fi
          
          # Set proper permissions
          chmod 600 ${{ steps.vars.outputs.ENV_FILE }}
          
          # Copy env file for Docker
          cp ${{ steps.vars.outputs.ENV_FILE }} .env
          
          # Ensure DB_HOST and REDIS_HOST point to container names
          sed -i 's/^DB_HOST=.*/DB_HOST=postgres/' .env
          sed -i 's/^REDIS_HOST=.*/REDIS_HOST=redis/' .env
          
          # If REDIS_HOST doesn't exist, add it
          grep -q "^REDIS_HOST=" .env || echo "REDIS_HOST=redis" >> .env
          
          # Ensure DB credentials match what's in docker-compose
          sed -i 's/^DB_DATABASE=.*/DB_DATABASE=ezship_production/' .env
          sed -i 's/^DB_USERNAME=.*/DB_USERNAME=ezship_user/' .env
          
          # Show database config for debugging (mask password)
          echo "=== Database Configuration ==="
          grep -E "^DB_" .env | sed 's/DB_PASSWORD=.*/DB_PASSWORD=***MASKED***/' | head -10
          
          # Extract actual DB password for docker-compose
          export DB_PASSWORD=$(grep "^DB_PASSWORD=" .env | cut -d'=' -f2)
          echo "DB_PASSWORD length: ${#DB_PASSWORD} characters"
          
          # Create necessary directories
          mkdir -p storage/app/public
          mkdir -p storage/framework/{cache,sessions,views}
          mkdir -p storage/logs
          mkdir -p bootstrap/cache
          
          # Stop any service using port 80
          sudo systemctl stop nginx 2>/dev/null || true
          sudo systemctl stop apache2 2>/dev/null || true
          sudo lsof -ti:80 | xargs sudo kill -9 2>/dev/null || true
          
          # Build and restart containers (with volume cleanup for fresh DB)
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} down -v || true
          docker volume rm ezship_postgres-prod-data 2>/dev/null || true
          
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} pull
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} build --no-cache
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} up -d
          
          # Wait for containers to be ready
          sleep 10
          
          # Wait a bit more for containers to stabilize
          sleep 15
          
          # Check container status
          echo "=== Container Status ==="
          docker ps -a | grep ezship
          
          # Always show app container logs for debugging
          echo "=== App Container Logs ==="
          docker logs --tail 50 ${{ steps.vars.outputs.CONTAINER_NAME }} || true
          
          # Check if container is running
          if ! docker ps | grep -q "${{ steps.vars.outputs.CONTAINER_NAME }}"; then
            echo "ERROR: App container is not running!"
            echo "=== Full Container Logs ==="
            docker logs ${{ steps.vars.outputs.CONTAINER_NAME }} || true
            echo "=== Container Inspect ==="
            docker inspect ${{ steps.vars.outputs.CONTAINER_NAME }} | grep -A 10 "State" || true
          fi
          
          # Run migrations (use service name 'app' instead of container name)
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T app php artisan migrate --force || echo "Migration failed or container not running"
          
          # Clear and rebuild caches for production
          if [[ "${{ steps.vars.outputs.ENV_TYPE }}" == "prod" ]]; then
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T app php artisan config:cache || true
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T app php artisan route:cache || true
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T app php artisan view:cache || true
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T app php artisan optimize || true
          else
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T app php artisan config:clear || true
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T app php artisan cache:clear || true
          fi
          
          # Test nginx to app connectivity
          echo "=== Testing Nginx to App Connectivity ==="
          docker exec ezship-nginx-prod wget -O- http://app:9000 2>&1 | head -20 || echo "Direct PHP-FPM test failed (expected)"
          docker exec ezship-nginx-prod cat /etc/nginx/nginx.conf | grep -A 5 "upstream" || true
          
          # Clean up Docker resources
          docker system prune -f
          
          echo "Deployment completed to ${{ steps.vars.outputs.API_URL }}"

    - name: Health Check
      run: |
        echo "Waiting for API to be available..."
        sleep 30
        
        if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
          # Use HTTP for now until SSL is configured
          API_URL="http://${{ secrets.SERVER_HOST }}"
          API_URL_HTTPS="https://api.ezship.app"
          echo "Checking Production API: $API_URL (HTTP) and $API_URL_HTTPS (HTTPS)"
        else
          API_URL="http://${{ secrets.SERVER_HOST }}"
          API_URL_HTTPS="https://api-dev.ezship.app"
          echo "Checking Development API: $API_URL (HTTP) and $API_URL_HTTPS (HTTPS)"
        fi
        
        # Check API health with more detail
        echo "Testing API URL: $API_URL"
        
        # Test HTTP first (should work)
        echo "=== Testing HTTP ==="
        response_http=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 10 $API_URL || echo "000")
        echo "HTTP Response Code: $response_http"
        
        # Show actual response
        echo "HTTP Response Body (first 20 lines):"
        curl -s -L --max-time 5 $API_URL 2>&1 | head -20 || echo "Failed to get response"
        
        # Test HTTPS (might fail if SSL not configured)
        echo "=== Testing HTTPS ==="
        response_https=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 10 $API_URL_HTTPS || echo "000")
        echo "HTTPS Response Code: $response_https"
        
        response=$response_http
        
        if [ $response -eq 200 ] || [ $response -eq 301 ] || [ $response -eq 302 ] || [ $response -eq 404 ] || [ $response -eq 500 ]; then
          echo "✅ API is responding with status code: $response"
        else
          echo "⚠️ API returned status code: $response (might still be starting up)"
        fi
        
        # Try API health endpoint if available
        health_response=$(curl -s -o /dev/null -w "%{http_code}" $API_URL/api/health || echo "000")
        if [ $health_response -eq 200 ]; then
          echo "✅ API health endpoint responding: $health_response"
        fi
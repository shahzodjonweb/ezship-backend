name: Docker Deploy

on:
  push:
    branches: [ master, dev ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=raw,value=latest,enable={{is_default_branch}}
          type=sha

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
    - name: Set deployment variables
      id: vars
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
          echo "ENV_TYPE=prod" >> $GITHUB_OUTPUT
          echo "COMPOSE_FILE=docker-compose.prod.yml" >> $GITHUB_OUTPUT
          echo "ENV_FILE=.env.prod" >> $GITHUB_OUTPUT
          echo "CONTAINER_NAME=ezship-app-prod" >> $GITHUB_OUTPUT
          echo "API_URL=https://api.ezship.app" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/dev" || "${{ github.ref }}" == "refs/heads/develop" ]]; then
          echo "ENV_TYPE=dev" >> $GITHUB_OUTPUT
          echo "COMPOSE_FILE=docker-compose.dev.yml" >> $GITHUB_OUTPUT
          echo "ENV_FILE=.env.dev" >> $GITHUB_OUTPUT
          echo "CONTAINER_NAME=ezship-app-dev" >> $GITHUB_OUTPUT
          echo "API_URL=https://api-dev.ezship.app" >> $GITHUB_OUTPUT
        fi

    - name: Deploy via SSH
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SERVER_SSH_KEY }}
        port: ${{ secrets.SERVER_PORT || 22 }}
        script: |
          # Navigate to deployment directory
          cd /opt/ezship
          
          # Pull latest code
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            git checkout master && git pull origin master
          else
            git checkout develop && git pull origin develop || git pull origin dev
          fi
          
          # Create environment file from GitHub Secret
          if [[ "${{ steps.vars.outputs.ENV_TYPE }}" == "prod" ]]; then
            cat > ${{ steps.vars.outputs.ENV_FILE }} << 'EOF'
          ${{ secrets.PRODUCTION_ENV_FILE }}
          EOF
          else
            cat > ${{ steps.vars.outputs.ENV_FILE }} << 'EOF'
          ${{ secrets.DEVELOPMENT_ENV_FILE }}
          EOF
          fi
          
          # Set proper permissions
          chmod 600 ${{ steps.vars.outputs.ENV_FILE }}
          
          # Copy env file for Docker
          cp ${{ steps.vars.outputs.ENV_FILE }} .env
          
          # Ensure DB_HOST and REDIS_HOST point to container names
          sed -i 's/^DB_HOST=.*/DB_HOST=postgres/' .env
          sed -i 's/^REDIS_HOST=.*/REDIS_HOST=redis/' .env
          
          # If REDIS_HOST doesn't exist, add it
          grep -q "^REDIS_HOST=" .env || echo "REDIS_HOST=redis" >> .env
          
          # Stop any service using port 80
          sudo systemctl stop nginx 2>/dev/null || true
          sudo systemctl stop apache2 2>/dev/null || true
          sudo lsof -ti:80 | xargs sudo kill -9 2>/dev/null || true
          
          # Build and restart containers
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} pull
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} build --no-cache
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} down
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} up -d
          
          # Wait for containers to be ready
          sleep 10
          
          # Wait a bit more for containers to stabilize
          sleep 15
          
          # Check container status
          echo "=== Container Status ==="
          docker ps -a | grep ezship
          
          # Always show app container logs for debugging
          echo "=== App Container Logs ==="
          docker logs --tail 50 ${{ steps.vars.outputs.CONTAINER_NAME }} || true
          
          # Check if container is running
          if ! docker ps | grep -q "${{ steps.vars.outputs.CONTAINER_NAME }}"; then
            echo "ERROR: App container is not running!"
            echo "=== Full Container Logs ==="
            docker logs ${{ steps.vars.outputs.CONTAINER_NAME }} || true
            echo "=== Container Inspect ==="
            docker inspect ${{ steps.vars.outputs.CONTAINER_NAME }} | grep -A 10 "State" || true
          fi
          
          # Run migrations (if container is running)
          docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T ${{ steps.vars.outputs.CONTAINER_NAME }} php artisan migrate --force || echo "Migration failed or container not running"
          
          # Clear and rebuild caches for production
          if [[ "${{ steps.vars.outputs.ENV_TYPE }}" == "prod" ]]; then
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T ${{ steps.vars.outputs.CONTAINER_NAME }} php artisan config:cache
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T ${{ steps.vars.outputs.CONTAINER_NAME }} php artisan route:cache
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T ${{ steps.vars.outputs.CONTAINER_NAME }} php artisan view:cache
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T ${{ steps.vars.outputs.CONTAINER_NAME }} php artisan optimize
          else
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T ${{ steps.vars.outputs.CONTAINER_NAME }} php artisan config:clear
            docker-compose -f ${{ steps.vars.outputs.COMPOSE_FILE }} exec -T ${{ steps.vars.outputs.CONTAINER_NAME }} php artisan cache:clear
          fi
          
          # Clean up Docker resources
          docker system prune -f
          
          echo "Deployment completed to ${{ steps.vars.outputs.API_URL }}"

    - name: Health Check
      run: |
        echo "Waiting for API to be available..."
        sleep 30
        
        if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
          API_URL="https://api.ezship.app"
          echo "Checking Production API: $API_URL"
        else
          API_URL="https://api-dev.ezship.app"
          echo "Checking Development API: $API_URL"
        fi
        
        # Check API health with more detail
        echo "Testing API URL: $API_URL"
        response=$(curl -s -o /dev/null -w "%{http_code}" -L $API_URL || echo "000")
        echo "API Response Code: $response"
        
        # Get actual response body for debugging
        echo "API Response Body:"
        curl -s -L $API_URL | head -100 || echo "Failed to get response"
        
        if [ $response -eq 200 ] || [ $response -eq 301 ] || [ $response -eq 302 ] || [ $response -eq 404 ] || [ $response -eq 500 ]; then
          echo "✅ API is responding with status code: $response"
        else
          echo "⚠️ API returned status code: $response (might still be starting up)"
        fi
        
        # Try API health endpoint if available
        health_response=$(curl -s -o /dev/null -w "%{http_code}" $API_URL/api/health || echo "000")
        if [ $health_response -eq 200 ]; then
          echo "✅ API health endpoint responding: $health_response"
        fi